
import numpy as np

def generate(fit_objects, bins=-1):
	"""
	Generates new spike trains from the extracted models.

		**fit_objects** 

			A list of ip.Models

		**bins**
	
			How many bins should be generated (should be multiples of trial_length)

	"""
	spikes = []
	if bins < 0:
		bins = fit_objects[0].trial_length
	fitted = fit_objects[0].family_fitted_function
	prototypes = [f.prototypes() for f in fit_objects]
	ps = []
	#autohistory = [p['autohistory'] for p in prototypes]
	crosshistory = []
	for j in range(len(fit_objects)):
		c = []
		for jj in range(len(fit_objects)):
			if jj == j:
				if 'autohistory' in prototypes[j]:
					c.append(prototypes[j]['autohistory'])
				else:
					c.append(np.zeros(1))
			else:
				if 'crosshistory'+str(jj) in prototypes[j]:
					c.append(prototypes[j]['crosshistory'+str(jj)])
				else:
					c.append(np.zeros(1))
		crosshistory.append(c)
	crosshistory_2d = []
	for j in range(len(fit_objects)):
		c = []
		if fit_objects[j].design.get_components('autohistory2d') != []:
			for comp in fit_objects[j].design.get_components('autohistory2d'):
				c.append((comp,fit_objects[j].beta[fit_objects[j].design.getIndex('autohistory2d')]))
		crosshistory_2d.append(c)
	rate = [f.firing_rate_model().sum(1) + f.prototypes()['constant'] for f in fit_objects]
	snd_rate = [np.zeros(bins) for f in fit_objects]
	time = np.zeros((bins,len(fit_objects)))
	ps = []
	for i in range(len(fit_objects)):
		ps.append([])
	for t in range(bins):
		for cell in range(len(fit_objects)):
			rand = np.random.rand()
			p = rate[cell][t] + snd_rate[cell][t]
			ps[cell].append(fitted(p))
			if rand < fitted(p):
				time[t,cell] = 1
				#kernel_end = np.min([autohistory[j].shape[0],len(rate[j]) - t])
				#rate[j][t+1:t+kernel_end] = rate[j][t+1:t+kernel_end] + autohistory[j][1:kernel_end]
				for jj in range(len(fit_objects)):
					kernel_end = np.min([crosshistory[jj][cell].shape[0],len(rate[cell]) - (t+1)])						
					if kernel_end > 1:
						rate[jj][(t+1):t+1+kernel_end] = rate[jj][(t+1):t+1+kernel_end] + crosshistory[jj][cell][0:kernel_end]
						#rate[jj][(t+1):t+kernel_end] = rate[jj][(t+1):t+kernel_end] + crosshistory[jj][cell][1:kernel_end]
						#rate[cell][(t+2):t+1+kernel_end] = rate[cell][(t+2):t+1+kernel_end] + crosshistory[cell][jj][1:(kernel_end)]
				if crosshistory_2d[cell] != []:
					snd_rate[cell] = np.zeros(bins)
					for cr in crosshistory_2d[cell]:
						c = cr[0]
						b = cr[1]
						snd_rate[cell] = snd_rate[cell] + c.getSplines([time[:,c] for c in range(len(fit_objects))], beta=b)
	return (time,np.array(ps))


def generate_replace(fit_object, data, bins=-1):
	"""
	Generates new spike trains from the extracted staistics

	Currently uses rate model and autohistory.

		**bins**
	
			How many bins should be generated (should be multiples of trial_length)

		**data**

			If specified, data is generated by replacing each spike train in the data with a generated spike train that uses the crosshistories from the data
			
	"""
	spikes = []
	channels = data.getFlattend(all_in_one=False)
	if bins < 0:
		bins = fit_object.trial_length
	fitted = fit_object.family_fitted_function
	prototypes = fit_object.getPrototypes()
	weights = fit_object.getWeights()
	ps = []
	rate = fit_object.firing_rate_model().sum(1) + fit_object.prototypes()['constant']
	time = np.zeros(bins)
	for t in range(bins):
		rand = np.random.rand()
		p = rate[t]
		ps.append(p)
		if rand < fitted(p):
			time[t] = 1
			kernel_end = np.min([prototypes['autohistory'].shape[0],len(rate) - t])						
			if kernel_end > 1:
				rate[(t+1):t+kernel_end] = rate[(t+1):t+kernel_end] + prototypes['autohistory'][1:kernel_end]
			for jj in range(len(fit_objects)):
				for t_minus in range(1,prototypes['autohistory_2d'].shape[0]):
					if time[t - t_minus,jj] == 1:
						kernel_end = np.min([prototypes['autohistory_2d'].shape[0],len(rate) - t])						
						if kernel_end > 1:
							rate[(t+1):t+kernel_end] = rate[(t+1):t+kernel_end] + prototypes['autohistory_2d'][1:kernel_end,t_minus]
		for cell in [c for c in range(data.nr_cells) if c != fit_object.cell]:
			if channels[cell][t]:
				kernel_end = np.min([prototypes['crosshistory'+str(cell)].shape[0],len(rate) - t])						
				if kernel_end > 1:
					rate[(t+1):t+kernel_end] = rate[(t+1):t+kernel_end] + prototypes['crosshistory'+str(cell)][1:kernel_end,t_minus]
	return (time,np.array(ps))


