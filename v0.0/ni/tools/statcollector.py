"""
.. module:: ni.tools.statcollector
   :platform: Unix
   :synopsis: Collects information into a dictionary of dictionaries and provides tools for visualization

.. moduleauthor:: Jacob Huth <jahuth@uos.de>

"""
import numpy as np
import pickle
from pylab import figure
import matplotlib.pylab as plt
import matplotlib.pylab as pl
from ni.tools.plot import *
from ni.tools.html_view import View
from copy import copy
import glob

def listToPath(name):
    """
        Creates a string that joins a list together with slashes. The list can contain strings and numbers.
    """
    if type(name) == list:
        n = "/".join([str(e) for e in name])
    else:
        n = str(name)
    return n

import re

def atoi(text):
    """ converts text containing numbers into ints / used by :func:`natural_keys`"""
    return int(text) if text.isdigit() else text

def natural_keys(text):
    '''
    alist.sort(key=natural_keys) sorts in human order
    (See Toothy's implementation in the comments of http://nedbatchelder.com/blog/200712/human_sorting.html )
    '''
    return [ atoi(c) for c in re.split('(\d+)', text) ]

def natural_sorted(l):
	""" sorts a sortable in human order (0 < 20 < 100) """
	ll = copy(l)
	ll.sort(key=natural_keys)
	return ll
    
class StatCollector:
	"""

		A class to collect statistics about models. It can be used to analyse nested models, as slashes in the name are interpreted as submodels.

		Example:

			>>> rate model/0
			>>> rate model/1
			>>> rate model/2
			>>> rate model/3
			>>> nested model/0
			>>> nested model/1
			>>> nested model/2
			>>> nested model/3
			>>> nested model/0/1
			>>> nested model/0/2
			>>> nested model/0/3
			>>> nested model/0/2/1
			>>> nested model/0/2/3
			>>> nested model/0/2/3/1

		This example could be generated by fitting a model with a certain number of crosshistory cells. In each iteration the best model is extended by another cell.
		The nested model can then be evaluated whether it has increasing likelihood and/or eic, aic or other statistics:

			>>> stats.getModelsOnPath(['nested model',0,2,3,1]).get('eic')
			[ -1023, -1020, -900, -950 ]

		self.stats: a dict of lists, each list containing dicts with:
			name
			llf
			eic, aic, eice, complexity (optional)
			additional  - a dict with more information (ignored for now)
	"""
	def __init__(self, stat_init = {}):
		self.stats = {}
		if stat_init != {}:
			self.stats = stat_init
		self.path=""
	def addNode(self,name,data={}):
		""" adds the node `name` with the attributes in the dictionary `dic`. If `name` exists, it wll be overwritten. """
		n = listToPath(name)
		self.stats[n] = data
		return name
	def getNode(self,name):
		""" returns a dictionary with all attributes of the node `name` """
		n = listToPath(name)
		return self.stats[n]
	def addToNode(self,name,dic):
		""" adds all attributes in the dictionary `dic` to the node `name` """
		n = listToPath(name)
		if not n in self.stats:
			self.stats[n] = dic
		else:
			self.stats[n].update(dic)
		return name
	def set(self,name,key,value):
		""" sets one attribute for node `name` """
		n = listToPath(name)
		self.stats[n][key] = value
	def getDimensions(self):
		""" returns which dimensions are availble for the contained nodes """
		dimensions = set()
		for s in self.stats.keys():
			dimensions.update(self.stats[s].keys())
		return dimensions
	def get(self,dim):
		"""
			returns a numpy ndarray with the `dim` attributes of each node that contains `dim`
		"""
		if type(dim) == list:
			l = []
			for k in sorted(self.stats.keys(),key=natural_keys):
				if np.all([ d in self.stats[k] for d in dim]):
					l.append([self.stats[k][d] for d in dim])
			return np.array(l).transpose()
		return np.array([self.stats[k][dim] for k in sorted(self.stats.keys(),key=natural_keys) if dim in self.stats[k]])
	def getList(self,dim):
		"""
			returns a list with the `dim` attributes of each node that contains `dim`
		"""
		if type(dim) == list:
			l = []
			for k in sorted(self.stats.keys(),key=natural_keys):
				if np.all([ d in self.stats[k] for d in dim]):
					l.append([self.stats[k][d] for d in dim])
			return l
		return [self.stats[k][dim] for k in sorted(self.stats.keys(),key=natural_keys) if dim in self.stats[k]]
	def filter(self,name):
		"""
			returns a StatCollector Object with only a subset of models
		"""
		n = listToPath(name)
		stats = {}
		for k in self.stats.keys():
			if k.startswith(n):
				stats[k] = self.stats[k]
		return StatCollector(stats)
	def re(self,regex):
		"""
			returns a StatCollector Object with only a subset of models
		"""
		stats = {}
		for k in self.stats.keys():
			if re.match(regex,k) != None:
				stats[k] = self.stats[k]
		return StatCollector(stats)
	def getModelsOnPath(self,name):
		""" returns models that lead to the node `name` """
		stats = {}
		sub_name = []
		if not type(name) == list:
			name = name.split('/')
		for s in name:
			sub_name.append(s)
			n = listToPath(sub_name)
			for k in self.stats.keys():
				if k == n:
					stats[k] = self.stats[k]
		return StatCollector(stats)
	def __str__(self):
		""" returns a string representation of some of the values of each node """
		for k in self.stats.keys():
			print k
			print 'llf:', [m['llf'] for m in self.stats[k] if 'llf' in m]
			print 'eic:', [m['eic'] for m in self.stats[k] if 'eic' in m]
			print 'aic:', [m['aic'] for m in self.stats[k] if 'aic' in m]
			print 'complexity:', [m['complexity'] for m in self.stats[k] if 'complexity' in m]
	def save(self, filename):
		"""
			Saves the StatCollector to `filename`.

			This file will be a pickled dictionary.

		"""
		f = open(filename,"w")
		pickle.dump(self.stats,f)
		f.close()
	def load(self,filename):
		"""
			Loads the StatCollector saved to `filename`.

			This file should be a pickled dictionary.

		"""
		try:
			f = open(filename,"r")
			self.stats = pickle.load(f)
			f.close()
		except:
			print "Could not open file ",filename
			raise
	def load_list(self,filenames):
		""" loads a list of files """
		return self.loadList(filenames)
	def loadList(self,filenames):
		""" loads a list of files. (Alias of :func:`StatCollector.load_list`) """
		self.stats = {}
		for filename in filenames:
			try:
				f = open(filename,"r")
				self.stats.update(pickle.load(f))
				f.close()
			except:
				pass
				#print "Could not open file ",filename
	def load_glob(self,filename_template):
		return self.load_list(glob.glob(filename_template))
	def plotHist(self,path,width,dims):
		""" plots a histogram of each dimension in `dims`"""
		fig = figure(figsize=(10,7))
		#subplot(2,1,1, title='EIC values for models of cell '+str(cell))
		for d in dims:
			zz = self.getList([d['name']])
			for i in range(len(zz)):
				(x,y) = plotHist(zz[i],d['line'],d['marker'],width=width)
		fig.savefig(path + '.png')
	def nodes(self):
		""" returns the name of all nodes. Synonym of :func:`StatCollector.keys()` """
		return self.stats.keys()
	def keys(self):
		""" returns the name of all nodes. Synonym of :func:`StatCollector.nodes()` """
		return self.stats.keys()
	def getChildren(self):
		_stats = {}
		for k in self.stats.keys():
			ns = k.split("/")
			if not ns[0] in _stats:
				_stats[ns[0]] = StatCollector({})
				_stats[ns[0]].path = self.path + "/" + ns[0]
			_stats[ns[0]].addNode(ns[1:], self.stats[k])
		return _stats
	def split(self,keys):
		""" Takes a portion of the property names and makes it a node """
		_stats = StatCollector({})
		for k in self.stats.keys():
			saved = False
			for prop in self.stats[k].keys():
				saved = False
				for key in keys:
					if prop.startswith(key):
						_stats.addToNode([k,key],{prop.replace(key,"",1):self.stats[k][prop]})
						saved = True
				if not saved:
					_stats.addToNode(k,{prop:self.stats[k][prop]})
		_stats.path = self.path
		return _stats
	def prefix(self,prefix="/"):
		""" Makes the last node a part of the property name """
		_stats = StatCollector({})
		for k in self.stats.keys():
			ns = k.split("/")
			for prop in self.stats[k].keys():
				_stats.addToNode(ns[:-1],{ns[-1] + prefix + prop:self.stats[k][prop]})
		return _stats
	def pull_from_inner_dict(self, from_dictionary='statistics', from_key='bic', to_key='BIC'):
		"""
			If a dictionary is added as a dimension, this function can pull values from that dictionary and add them to each node that has the specific dictionary.
			As the bootstrap functions add the statistics dictionary of the model fit to the node, this function has to be used to eg. access the BIC criterion (which is why this is the default from and to keys). 
		"""
		for k in self.keys():
			if from_dictionary in self.stats[k]:
				if from_key in self.stats[k][from_dictionary]:
					self.stats[k][to_key] = self.stats[k][from_dictionary][from_key]
	def rename(self,pattern,substitution):
		"""
			Renames nodes with the regex pattern `pattern` just like :func:`re.sub()`.

			Example to rename different number of knots to a tree, where each the increase in knots is counted as a submodel::

				statsr = stats.rename(r'50','30/50').rename(r'30','20/30').rename(r'20','10/20').rename(r'10','5/10').rename(r'5','3/5').rename(r'30/3/50','30/50')

		"""
		_stats = StatCollector({})
		for k in self.stats.keys():
			new_k = re.sub(pattern,substitution,k)
			_stats.stats[new_k] = self.stats[k]
		return _stats
	def rename_value_to_tree(self, value=-1):
		"""

			Renames nodes, such that increases of one value are counted as submodels

			`value` is the index (of the slash splitted node name) of the value that is to be replaced. The default is -1, ie. the last value.

			Example::

				import ni
				stats = ni.StatCollector()
				stats.addNode('Model 0/10',{'a':100})
				stats.addNode('Model 0/20',{'a':100})
				stats.addNode('Model 0/30',{'a':100})
				stats.addNode('Model 0/50',{'a':100})
				stats.addNode('Model 0/1000',{'a':100})
				stats.rename_value_to_tree().plotTree('a')

			The example will rename the last node to 'Model 0/10/20/30/50/1000'

		"""
		values = []
		for k in self.stats.keys():
			if value < len(k.split("/")):
				values.append(k.split("/")[value])
		values = natural_sorted(list(set(values)))
		_stats = StatCollector({})
		for k in self.stats.keys():
			new_k = k.split("/")
			if value < len(new_k):
				this_value = None
				for (i,v) in enumerate(values):
					if v == new_k[value]:
						this_value=i+1
						break
				if this_value is not None:
					new_k[value] = "/".join(values[:this_value])
			_stats.stats["/".join(new_k)] = self.stats[k]
		return _stats
	def getTree(self,substitution_patterns=[]):
		"""
			returns a tuple used by plotTree to plot a tree representation of the nodes.
		"""
		l = []
		model_points = []
		for k in self.keys():
			model_points.append(([k.count("/")],[k],'go'))
			for k_2 in self.keys():
				for (p,s,c) in substitution_patterns:
					if re.sub(p,s,k).startswith(k_2):
						l.append(([k_2.count("/"),k.count("/")],[k_2,k],c))
				if k.startswith(k_2) and k_2.count("/") == k.count("/")-1:
					l.append(([k_2.count("/"),k.count("/")],[k_2,k],'g--'))
		return l,model_points
	def plotTree(self,dim,substitution_patterns=[],line_kwargs={},marker_kwargs={}, right_to_left = False):
		"""
			Plots a tree of the nodes, using `dim` as the height, if the node contains `dim`.

			Slashes in the model names will be used as the different levels in the tree. The order of the parts between the slashes is ignored for now (3/4 and 4/3 are the same).

			`substitution_patterns` may contain substitution patterns (used to connect nodes) for re.sub as a three tuple (pattern, substitute, color), where color is the color that will be assigned to this connection

			`line_kwargs` and `marker_kwargs` can contain arguments in a dictionary to alter the options to set lines or markers. The dictionary will be passed on to the plot function.

			`right_to_left` determines, whether the plot is plotted from left to right (default) or the other way around (`right_to_left` = True).


		"""
		right_to_left_mult = 1
		if right_to_left:
			right_to_left_mult = -1
		l, model_points = self.getTree(substitution_patterns)
		last_y = 0
		for ll in l:
			if ll[1][0] in self.keys() and ll[1][1] in self.keys():
				plt.plot([right_to_left_mult*ll[0][0],right_to_left_mult*ll[0][1]], [np.mean(self.getNode(ll[1][0])[dim]),np.mean(self.getNode(ll[1][1])[dim])],ll[2],**line_kwargs)
		for ll in model_points:
			if ll[1][0] in self.keys():
				plt.plot(right_to_left_mult*ll[0][0], np.mean(self.getNode(ll[1][0])[dim]),ll[2],**marker_kwargs)
				x = ll[0][0]
				y = np.mean(self.getNode(ll[1][0])[dim])
				if abs(last_y-y) < 0.1:
					y = y + 0.1
				if 'name' in self.getNode(ll[1][0]):
					plt.text(x,y, self.getNode(ll[1][0])['name'],rotation=30,va='bottom',size=9)
				else:
					plt.text(x,y, ll[1][0],rotation=30,va='bottom',size=9)
		plt.title(dim)
	def html_view(self):
		"""
			Generates an html_view of this object. 

			Example::

				stats.html_view().render('stats_file.html')


		"""
		view = View()
		stat_prefix = ""
		for k in self.keys():
			view.add(stat_prefix + "#2/tabs/Models/"+k.replace("/","/tabs/"),k)
			node = self.getNode(k)
			for prop in node:
				if type(node[prop]) == np.float64:
					view.add(stat_prefix + "#2/tabs/Models/"+k.replace("/","/tabs/")+"/#1/"+prop,prop+" = "+str(node[prop]))
				if type(node[prop]) == list:
					with view.figure(stat_prefix + "#2/tabs/Models/"+k.replace("/","/tabs/")+"/Plots/tabs/"+prop):
						pl.plot(node[prop])
		for d in self.getDimensions():	
			x = self.get(d)
			if type(x[0]) == np.string_:
					view.add(stat_prefix + "#2/tabs/Dimensions/tabs/"+d+"/",str(x))
			elif len(x.shape) == 1:
				try:
					with view.figure("#2/tabs/Dimensions/tabs/"+d+"/#1"):
						pl.plot(x)
				except:
					view.add(stat_prefix + "#2/tabs/Dimensions/tabs/"+d+"/#1/failed",x)
			elif len(x.shape) == 2:
				try:
					with view.figure(stat_prefix + "#2/tabs/Dimensions/tabs/"+d+"/#1"):
						pl.plot(x)
					with view.figure(stat_prefix + "#2/tabs/Dimensions/tabs/"+d+"/#2"):
						pl.plot(x.transpose())
				except:
					with view.figure(stat_prefix + "#2/tabs/Dimensions/tabs/"+d+"/#1/failed"):
						for xx in x:
							for xxx in xx:
								pl.plot(xxx)
			elif len(x.shape) == 3:
				try:
					with view.figure(stat_prefix +"#2/tabs/Dimensions/tabs/"+d+"/tabs/Axis 0/#1"):
						pl.plot(np.mean(x,axis=0))
					with view.figure(stat_prefix + "#2/tabs/Dimensions/tabs/"+d+"/tabs/Axis 0/#2"):
						pl.plot(np.mean(x,axis=0).transpose())
					with view.figure(stat_prefix + "#2/tabs/Dimensions/tabs/"+d+"/tabs/Axis 1/#1"):
						pl.plot(np.mean(x,axis=1))
					with view.figure(stat_prefix + "#2/tabs/Dimensions/tabs/"+d+"/tabs/Axis 1/#2"):
						pl.plot(np.mean(x,axis=1).transpose())
					with view.figure(stat_prefix + "#2/tabs/Dimensions/tabs/"+d+"/tabs/Axis 2/#1"):
						pl.plot(np.mean(x,axis=2))
					with view.figure(stat_prefix + "#2/tabs/Dimensions/tabs/"+d+"/tabs/Axis 2/#2"):
						pl.plot(np.mean(x,axis=2).transpose())
				except:
					view.add(stat_prefix + "#2/tabs/Dimensions/tabs/"+d+"/#1/failed",x)
		return view
"""
	def tree_plot():	


		..todo:: make work


		N = data.nr_cells
		l = []
		for i in range(N):
			l.append(([0,1],["False", "["+str(i)+"]"],'b'))
		for i in range(N):
			for j in range(i+1,N):
				l.append(([1,2],["["+str(i)+"]",str(i)+"/"+str(j)],'g'))
				l.append(([1,2],["["+str(j)+"]",str(i)+"/"+str(j)],'g--'))
		model_points = ["False"]
		for i in range(N):
			model_points.append(([1],["["+str(i)+"]"],'bo'))
			for j in range(i+1,N):
				model_points.append(([2],[str(i)+"/"+str(j)],'go'))

		for dim in ['llf_test_model','EIC','AIC','llf_boot','llf_train']:
			textxys = []
			view.figure()
			figsize(7,20)
			last_y = 0
			for ll in l:
				if "Model "+ll[1][0] in stats.keys() and "Model "+ll[1][1] in stats.keys():
					plot(ll[0], [mean(stats.filter("Model "+ll[1][0]).get(dim)[0]),mean(stats.filter("Model "+ll[1][1]).get(dim)[0])],ll[2])
					#x = ll[0][1]
					#y = mean(stats.filter("Model "+ll[1][1]).get(dim)[0])
					#if abs(last_y-y) < 0.1:
					#	y = y + 0.1
					#text(x,y, "Model "+ll[1][1],rotation=30,va='bottom',size=9)
			for ll in model_points:
				if "Model "+ll[1][0] in stats.keys():
					x = ll[0][0]
					y = mean(stats.filter("Model "+ll[1][0]).get(dim)[0])
					if abs(last_y-y) < 0.1:
						y = y + 0.1
					text(x,y, "Model "+ll[1][0],rotation=30,va='bottom',size=9)
			title(dim)
			view.savefig("Cells/tabs/Cell "+str(cell)+"/tabs/Trees/tabs/"+dim)"""
